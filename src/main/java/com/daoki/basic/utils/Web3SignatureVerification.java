package com.daoki.basic.utils;

import java.security.SignatureException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.web3j.crypto.Keys;
import org.web3j.crypto.Sign;
import org.web3j.utils.Numeric;

/**
 * This class gives example code of verifying the Signature signed by Web3
 * crypto wallets like MetaMask etc..
 */
public class Web3SignatureVerification {

    private static final Logger log = LoggerFactory.getLogger(Web3SignatureVerification.class);

    /**
     * Internal utility method on servers side. You can do extract things after the both keys are matched.
     * @param address
     * @param signedMessage
     * @param originalMessage
     */
    public static boolean verifySignature(String address, String signedMessage, String originalMessage) throws SignatureException {

        String decryptedAddress = getAddressUsedToSignHashedPrefixedMessage(signedMessage, originalMessage);
        decryptedAddress = "0x" + decryptedAddress;
        System.out.println("Address :          " + address);
        System.out.println("decryptedAddress : " + decryptedAddress);
        // val messageHashBytes = Numeric.hexStringToByteArray(messageHashed)

        if(address.equals(decryptedAddress)) {
            // if verification successfull, you can build other business logic here.
            System.out.println("Signature Verified");
            return true;
        } else {
            System.err.println("Signature Verified Failed");
            return false;
        }
    }

    /**
     * This method using web3j api to retrieve the address which is used for singing the originalMessage.
     *
     * @param signedHash hashed messages which was generated by hashing the originalMessage.
     *        in MVC framework scenarios, the client application requests the any Crypto Provider (Like Metamask) to sign the message.
     *        Once signed the messages you will get signedHash. This signedHash will be sent to the server for verification (can be used as authenticating the user account).
     *
     * @param originalMessage the message which client requests Crypto provider for Signing it.
     *
     * @return
     */
    private static String getAddressUsedToSignHashedPrefixedMessage(String signedHash, String originalMessage) throws SignatureException {

        String r = signedHash.substring(0, 66);
        String s = "0x" + signedHash.substring(66, 130);
        String v = "0x" + signedHash.substring(130, 132);
        log.info(v);

        String pubkey = Sign.signedPrefixedMessageToKey(originalMessage.getBytes(), new Sign.SignatureData(
                        Numeric.hexStringToByteArray(v)[0], Numeric.hexStringToByteArray(r), Numeric.hexStringToByteArray(s)))
                .toString(16);

        log.info("Pubkey: " + pubkey);
        return Keys.getAddress(pubkey);
    }

    public static boolean verify(String signature, String address, String originalMessage) throws SignatureException {
        return Web3SignatureVerification.verifySignature(address, signature,originalMessage);
    }
}